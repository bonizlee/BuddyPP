package util.debug;


import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class BDPreprocessor 
{
    // stores number of built user-defined function prototypes
    public int prototypeCount = 0;

    // stores number of included library headers written
    // we always write one header: Arduino.h
    public int headerCount = 1;
	  
    // the prototypes that are generated by the preprocessor
    List<String> prototypes;

    // these ones have the .* at the end, since a class name might be at the end
    // instead of .* which would make trouble other classes using this can lop
    // off the . and anything after it to produce a package name consistently.
    List<String> programImports;

    // imports just from the code folder, treated differently
    // than the others, since the imports are auto-generated.
    List<String> codeFolderImports;

    String indent;

    PrintStream stream;
    String program;
    String buildPath;
    // starts as sketch name, ends as main class name
    String name;
	  
    static String substituteUnicode(String program) 
    {
        // check for non-ascii chars (these will be/must be in unicode format)
        char p[] = program.toCharArray();
        int unicodeCount = 0;

        for (int i = 0; i < p.length; i++) {
            if (p[i] > 127) {
                unicodeCount++;
            }
        }
        // if non-ascii chars are in there, convert to unicode escapes
        if (unicodeCount != 0) {
            // add unicodeCount * 5.. replacing each unicode char
            // with six digit uXXXX sequence (xxxx is in hex)
            // (except for nbsp chars which will be a replaced with a space)
            int index = 0;
            char p2[] = new char[p.length + unicodeCount * 5];

            for (int i = 0; i < p.length; i++) {
                if (p[i] < 128) {
                    p2[index++] = p[i];

                } else if (p[i] == 160) { // unicode for non-breaking space
                    p2[index++] = ' ';

                } else {
                    int c = p[i];

                    p2[index++] = '\\';
                    p2[index++] = 'u';
                    char str[] = Integer.toHexString(c).toCharArray();

                    // add leading zeros, so that the length is 4
                    // for (int i = 0; i < 4 - str.length; i++) p2[index++] = '0';
                    for (int m = 0; m < 4 - str.length; m++) {
                        p2[index++] = '0';
                    }
                    System.arraycopy(str, 0, p2, index, str.length);
                    index += str.length;
                }
            }
            program = new String(p2, 0, index);
        }
        return program;
    }

    static public String scrubComments(String what) 
    {
        char p[] = what.toCharArray();

        int index = 0;

        while (index < p.length) 
        {
            // for any double slash comments, ignore until the end of the line
            if ((p[index] == '/') && (index < p.length - 1)
                    && (p[index + 1] == '/')) {
                p[index++] = ' ';
                p[index++] = ' ';
                while ((index < p.length) && (p[index] != '\n')) {
                    p[index++] = ' ';
                }

                // check to see if this is the start of a new multiline comment.
                // if it is, then make sure it's actually terminated somewhere.
            } 
            else if ((p[index] == '/') && (index < p.length - 1)
                    && (p[index + 1] == '*')) {
                p[index++] = ' ';
                p[index++] = ' ';
                boolean endOfRainbow = false;

                while (index < p.length - 1) {
                    if ((p[index] == '*') && (p[index + 1] == '/')) {
                        p[index++] = ' ';
                        p[index++] = ' ';
                        endOfRainbow = true;
                        break;

                    } else {
                        // continue blanking this area
                        p[index++] = ' ';
                    }
                }
                if (!endOfRainbow) {
                    throw new RuntimeException(
                            "Missing the */ from the end of a "
                                    + "/* comment */");
                }
            } else { // any old character, move along
                index++;
            }
        }
        return new String(p);
    }
	  
    public String strip(String in) 
    {
        // XXX: doesn't properly handle special single-quoted characters
        // single-quoted character
        String p = "('.')";
		    
        // double-quoted string
        p += "|(\"(?:[^\"\\\\]|\\\\.)*\")";
		    
        // single and multi-line comment       
        p += "|(//.*?$)|(/\\*[^*]*(?:\\*(?!/)[^*]*)*\\*/)";
		    
        // pre-processor directive
        p += "|" + "(^\\s*#.*?$)";

        Pattern pattern = Pattern.compile(p, Pattern.MULTILINE);
        Matcher matcher = pattern.matcher(in);

        return matcher.replaceAll(" ");
    }
	  
    /**
     * Removes the contents of all top-level curly brace pairs {}.
     * @param in the String to collapse
     * @return the collapsed String
     */
    private String collapseBraces(String in) 
    {
        StringBuffer buffer = new StringBuffer();
        
        int nesting = 0;
        int start = 0;
	    
        // XXX: need to keep newlines inside braces so we can determine the line
        // number of a prototype
        for (int i = 0; i < in.length(); i++) {
            if (in.charAt(i) == '{') {
                if (nesting == 0) {
                    buffer.append(in.substring(start, i + 1)); // include the '{'
                }
                nesting++;
            }
            if (in.charAt(i) == '}') {
                nesting--;
                if (nesting == 0) {
                    start = i; // include the '}'
                }
            }
        }
	    
        buffer.append(in.substring(start));
	    
        return buffer.toString();
    }
	  
    public ArrayList<String> prototypes(String in) 
    {
        in = collapseBraces(strip(in));
		    
        // XXX: doesn't handle ... varargs
        // XXX: doesn't handle function pointers
        Pattern prototypePattern = Pattern.compile(
                "[\\w\\[\\]\\*]+\\s+[&\\[\\]\\*\\w\\s]+\\([&,\\[\\]\\*\\w\\s]*\\)(?=\\s*;)");
        Pattern functionPattern = Pattern.compile(
                "[\\w\\[\\]\\*]+\\s+[&\\[\\]\\*\\w\\s]+\\([&,\\[\\]\\*\\w\\s]*\\)(?=\\s*\\{)");
		    
        // Find already declared prototypes
        ArrayList<String> prototypeMatches = new ArrayList<String>();
        Matcher prototypeMatcher = prototypePattern.matcher(in);

        while (prototypeMatcher.find()) {
            prototypeMatches.add(prototypeMatcher.group(0) + ";");
        }
		    
        // Find all functions and generate prototypes for them
        ArrayList<String> functionMatches = new ArrayList<String>();
        Matcher functionMatcher = functionPattern.matcher(in);

        while (functionMatcher.find()) {
            functionMatches.add(functionMatcher.group(0) + ";");
        }
		    
        // Remove generated prototypes that exactly match ones found in the source file
        for (int functionIndex = functionMatches.size() - 1; functionIndex >= 0; functionIndex--) {
            for (int prototypeIndex = 0; prototypeIndex
                    < prototypeMatches.size(); prototypeIndex++) {
                if ((functionMatches.get(functionIndex)).equals(
                        prototypeMatches.get(prototypeIndex))) {
                    functionMatches.remove(functionIndex);
                    break;
                }
            }
        }
		    
        return functionMatches;
    }
	  
    public List<String> getExtraImports() {
        return programImports;
    }
	  
    //代码预处理
    //program为代码内容，buildPath为生成cpp等文件的目录，sketchName为类名
    public int writePrefix(String program, String buildPath,
            String sketchName, String codeFolderPackages[]) 
        throws FileNotFoundException {
        this.buildPath = buildPath;
        this.name = sketchName;
		  
        program += "\n";
        scrubComments(program);
        program = substituteUnicode(program);

        
         String importRegexp = "^\\s*#include\\s*[<\"](\\S+)[\">]";	  
         
         programImports = new ArrayList<String>();	

         //原来：String[][] pieces = PApplet.matchAll(program, importRegexp);
         //追踪	programImports 的使�?
         String[][] pieces=matchAll(program, importRegexp);
         if (pieces != null)
         for (int i = 0; i < pieces.length; i++)
         programImports.add(pieces[i][1]);  // the package name
        
        codeFolderImports = new ArrayList<String>();		   

        prototypes = prototypes(program);
		    
        // store # of prototypes so that line number reporting can be adjusted
        prototypeCount = prototypes.size();
		  
        // do this after the program gets re-combobulated
        this.program = program;
		    
        // output the code
        try {        	
            File streamFile = new File(buildPath, name + ".cpp");
            stream = new PrintStream(new FileOutputStream(streamFile));
        }catch (Exception ex) {
        	throw ex;
        }
		    
        return headerCount + prototypeCount;		  
    }
	  
    public int firstStatement(String in) {
        // whitespace
        String p = "\\s+";
		    
        // multi-line and single-line comment
        
        p += "|(/\\*[^*]*(?:\\*(?!/)[^*]*)*\\*/)|(//.*?$)";

        // pre-processor directive
        p += "|(#(?:\\\\\\n|.)*)";
        Pattern pattern = Pattern.compile(p, Pattern.MULTILINE);
		      
        Matcher matcher = pattern.matcher(in);
        int i = 0;

        while (matcher.find()) {
            if (matcher.start() != i) {
                break;
            }
            i = matcher.end();
        }
		    
        return i;
    }
    
    static public String[][] matchAll(String what, String regexp) {
    Pattern p = Pattern.compile(regexp, Pattern.MULTILINE | Pattern.DOTALL);
    Matcher m = p.matcher(what);
    ArrayList<String[]> results = new ArrayList<String[]>();
    int count = m.groupCount() + 1;
    while (m.find()) {
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      results.add(groups);
    }
    if (results.isEmpty()) {
      return null;
    }
    String[][] matches = new String[results.size()][count];
    for (int i = 0; i < matches.length; i++) {
      matches[i] = (String[]) results.get(i);
    }
    return matches;
  }
	  
    protected void writeProgram(PrintStream out, String program, List<String> prototypes) {
        int prototypeInsertionPoint = firstStatement(program);
		  
        out.print(program.substring(0, prototypeInsertionPoint));
        out.print("#include \"Arduino.h\"\n");    
		    
        // print user defined prototypes
        for (int i = 0; i < prototypes.size(); i++) {
            out.print(prototypes.get(i) + "\n");
        }
        String[] lines = program.substring(0, prototypeInsertionPoint).split(
                "\n", -1);

        out.println("#line " + (lines.length - 1));
        out.print(program.substring(prototypeInsertionPoint));
    }
    
    public String write() throws java.lang.Exception {
        writeProgram(stream, program, prototypes);       
        stream.close();        
        return name;
    }
}
